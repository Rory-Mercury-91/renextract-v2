From d066581cface6056aacc95eb2c73fb258e8b6b85 Mon Sep 17 00:00:00 2001
From: Rory-Mercury-91 <a.fergani91@pm.me>
Date: Fri, 3 Oct 2025 18:27:56 +0200
Subject: [PATCH 1/2] :sparkles: Finished, implemente backup tab

---
 app.py                               | 106 ++++++++
 backup_manager.py                    | 393 +++++++++++++++++++++++++++
 src/components/Backup.svelte         | 319 ++++++++++++++++++++++
 src/components/ContentManager.svelte |  14 +-
 src/components/Settings.svelte       |  85 +-----
 src/components/WorkFolders.svelte    |  12 +-
 src/lib/api.ts                       |  55 ++++
 src/lib/constants.ts                 | 144 ++++++++++
 8 files changed, 1024 insertions(+), 104 deletions(-)
 create mode 100644 backup_manager.py
 create mode 100644 src/components/Backup.svelte
 create mode 100644 src/lib/constants.ts

diff --git a/app.py b/app.py
index 1a1f745..233947f 100644
--- a/app.py
+++ b/app.py
@@ -38,6 +38,112 @@ api_data = {
     'items': []
 }
 
+# Remplacer les lignes 41-49 dans app.py par :
+
+# Importer le nouveau gestionnaire de backup
+from backup_manager import BackupManager
+
+# Initialiser le gestionnaire
+backup_manager = BackupManager()
+
+@app.route('/api/backups', methods=['GET'])
+def get_backups():
+    """Liste toutes les sauvegardes avec filtres optionnels"""
+    try:
+        game_filter = request.args.get('game')
+        type_filter = request.args.get('type')
+        
+        backups = backup_manager.list_all_backups(
+            game_filter=game_filter,
+            type_filter=type_filter
+        )
+        
+        return jsonify({
+            'success': True,
+            'backups': backups
+        })
+    except Exception as e:
+        return jsonify({
+            'success': False,
+            'error': str(e)
+        }), 500
+
+@app.route('/api/backups/<backup_id>/restore', methods=['POST'])
+def restore_backup(backup_id):
+    """Restaure une sauvegarde"""
+    try:
+        # Trouver le backup dans les m√©tadonn√©es
+        if backup_id not in backup_manager.metadata:
+            return jsonify({
+                'success': False,
+                'error': 'Sauvegarde introuvable'
+            }), 404
+        
+        backup = backup_manager.metadata[backup_id]
+        target_path = backup.get('source_path')
+        
+        if not target_path or not os.path.exists(os.path.dirname(target_path)):
+            return jsonify({
+                'success': False,
+                'error': 'Chemin de destination invalide'
+            }), 400
+        
+        # Copier le fichier
+        import shutil
+        os.makedirs(os.path.dirname(target_path), exist_ok=True)
+        shutil.copy2(backup['backup_path'], target_path)
+        
+        # Supprimer la sauvegarde apr√®s restauration
+        os.remove(backup['backup_path'])
+        del backup_manager.metadata[backup_id]
+        backup_manager._save_metadata()
+        
+        return jsonify({
+            'success': True,
+            'message': 'Sauvegarde restaur√©e avec succ√®s'
+        })
+        
+    except Exception as e:
+        return jsonify({
+            'success': False,
+            'error': str(e)
+        }), 500
+
+@app.route('/api/backups/<backup_id>', methods=['DELETE'])
+def delete_backup(backup_id):
+    """Supprime une sauvegarde"""
+    try:
+        # Trouver le backup dans les m√©tadonn√©es
+        if backup_id not in backup_manager.metadata:
+            return jsonify({
+                'success': False,
+                'error': 'Sauvegarde introuvable'
+            }), 404
+        
+        backup = backup_manager.metadata[backup_id]
+        
+        # Supprimer le fichier
+        if os.path.exists(backup['backup_path']):
+            os.remove(backup['backup_path'])
+        
+        # Supprimer des m√©tadonn√©es
+        del backup_manager.metadata[backup_id]
+        backup_manager._save_metadata()
+        
+        # Nettoyer les dossiers vides
+        backup_manager.cleanup_empty_folders()
+        
+        return jsonify({
+            'success': True,
+            'message': 'Sauvegarde supprim√©e avec succ√®s'
+        })
+        
+    except Exception as e:
+        return jsonify({
+            'success': False,
+            'error': str(e)
+        }), 500
+
 
 @app.route('/api/health')
 def health_check():
diff --git a/backup_manager.py b/backup_manager.py
new file mode 100644
index 0000000..476e9ab
--- /dev/null
+++ b/backup_manager.py
@@ -0,0 +1,393 @@
+#!/usr/bin/env python3
+"""
+Backup Manager for RenExtract v2
+Standalone backup management system
+"""
+import os
+import shutil
+import datetime
+import json
+from typing import List, Dict, Optional
+from pathlib import Path
+
+class BackupType:
+    """√ânum√©ration des types de sauvegarde"""
+    SECURITY = "security"
+    CLEANUP = "cleanup"
+    RPA_BUILD = "rpa_build"
+    REALTIME_EDIT = "realtime_edit"
+
+class BackupManager:
+    """Gestionnaire de sauvegardes pour RenExtract v2"""
+    
+    BACKUP_DESCRIPTIONS = {
+        BackupType.SECURITY: "üõ°Ô∏è S√©curit√©",
+        BackupType.CLEANUP: "üßπ Nettoyage",
+        BackupType.RPA_BUILD: "üì¶ Avant RPA",
+        BackupType.REALTIME_EDIT: "‚ö° √âdition temps r√©el"
+    }
+    
+    # Configuration de rotation par type
+    ROTATION_CONFIG = {
+        BackupType.REALTIME_EDIT: 10,  # Max 10 fichiers pour editing
+        # Autres types: pas de rotation (None)
+    }
+    
+    def __init__(self, base_dir: str = None):
+        """Initialise le gestionnaire de sauvegardes"""
+        if base_dir is None:
+            base_dir = os.path.dirname(os.path.abspath(__file__))
+        
+        self.base_dir = base_dir
+        self.backup_root = os.path.join(base_dir, "03_Backups")
+        self.metadata_file = os.path.join(self.backup_root, "backup_metadata.json")
+        
+        # Cr√©er le dossier de backup s'il n'existe pas
+        os.makedirs(self.backup_root, exist_ok=True)
+        
+        self._load_metadata()
+    
+    def _load_metadata(self):
+        """Charge les m√©tadonn√©es des sauvegardes"""
+        try:
+            if os.path.exists(self.metadata_file):
+                with open(self.metadata_file, 'r', encoding='utf-8') as f:
+                    self.metadata = json.load(f)
+            else:
+                self.metadata = {}
+        except Exception as e:
+            print(f"Erreur chargement m√©tadonn√©es backups: {e}")
+            self.metadata = {}
+    
+    def _save_metadata(self):
+        """Sauvegarde les m√©tadonn√©es"""
+        try:
+            with open(self.metadata_file, 'w', encoding='utf-8') as f:
+                json.dump(self.metadata, f, indent=2, ensure_ascii=False)
+        except Exception as e:
+            print(f"Erreur sauvegarde m√©tadonn√©es backups: {e}")
+    
+    def _extract_game_name(self, filepath: str) -> str:
+        """Extrait le nom du jeu √† partir du chemin du fichier"""
+        try:
+            if not filepath:
+                return "Projet_Inconnu"
+            
+            if filepath.startswith("clipboard_"):
+                parts = filepath.split("_")
+                return f"Clipboard_{parts[2].replace('.rpy', '')}" if len(parts) >= 3 else "Projet_Clipboard"
+            
+            normalized_path = filepath.replace('\\', '/')
+            path_parts = [part for part in normalized_path.split('/') if part]
+            
+            # Chercher le dossier "game" dans le chemin
+            game_indices = [i for i, part in enumerate(path_parts) if part.lower() == 'game']
+            for game_index in reversed(game_indices):
+                if game_index > 0:
+                    game_name = path_parts[game_index - 1]
+                    return game_name
+            
+            # Fallback: utiliser le dossier parent
+            if len(path_parts) > 1:
+                parent_folder = path_parts[-2]
+                if ":" not in parent_folder:
+                    return parent_folder
+            
+            return "Projet_Inconnu"
+        except Exception as e:
+            print(f"Erreur extraction nom de jeu pour {filepath}: {e}")
+            return "Projet_Inconnu"
+    
+    def create_backup(self, source_path: str, backup_type: str = BackupType.SECURITY,
+                    description: str = None) -> Dict[str, any]:
+        """Cr√©e une sauvegarde avec la structure hi√©rarchique"""
+        result = {
+            'success': False,
+            'backup_path': None,
+            'backup_id': None,
+            'error': None
+        }
+    
+        try:
+            if not source_path or not os.path.exists(source_path):
+                result['error'] = "Fichier source introuvable"
+                return result
+        
+            if backup_type not in self.BACKUP_DESCRIPTIONS:
+                backup_type = BackupType.SECURITY
+        
+            # Gestion des fichiers virtuels
+            if source_path.startswith("clipboard_") and not os.path.exists(source_path):
+                result['success'] = True
+                result['error'] = None
+                result['virtual_file'] = True
+                result['message'] = "Fichier virtuel - pas de sauvegarde n√©cessaire"
+                return result
+        
+            # Extraire le nom du jeu et du fichier
+            game_name = self._extract_game_name(source_path)
+            file_name = Path(source_path).stem  # Nom sans extension
+            
+            # Cr√©er la structure hi√©rarchique: Game_name/file_name/backup_type/
+            backup_folder = os.path.join(self.backup_root, game_name, file_name, backup_type)
+            os.makedirs(backup_folder, exist_ok=True)
+        
+            timestamp = datetime.datetime.now()
+            timestamp_str = timestamp.strftime("%Y%m%d_%H%M%S")
+            
+            # Nom du fichier de sauvegarde (garder l'extension originale)
+            original_ext = Path(source_path).suffix
+            backup_filename = f"{file_name}_{timestamp_str}{original_ext}"
+            backup_path = os.path.join(backup_folder, backup_filename)
+        
+            # Copier le fichier
+            shutil.copy2(source_path, backup_path)
+        
+            # Appliquer la rotation si n√©cessaire
+            if backup_type in self.ROTATION_CONFIG:
+                self._apply_rotation(backup_folder, backup_type)
+        
+            # Cr√©er les m√©tadonn√©es
+            backup_id = f"{game_name}_{file_name}_{timestamp_str}_{backup_type}"
+        
+            backup_metadata = {
+                'id': backup_id,
+                'source_path': source_path,
+                'backup_path': backup_path,
+                'game_name': game_name,
+                'file_name': file_name,
+                'type': backup_type,
+                'created': timestamp.isoformat(),
+                'size': os.path.getsize(backup_path),
+                'description': description or f"Sauvegarde {self.BACKUP_DESCRIPTIONS[backup_type]}",
+                'source_filename': os.path.basename(source_path),
+                'backup_filename': backup_filename
+            }
+        
+            self.metadata[backup_id] = backup_metadata
+            self._save_metadata()
+        
+            result['success'] = True
+            result['backup_path'] = backup_path
+            result['backup_id'] = backup_id
+        
+            print(f"Backup cr√©√©: {game_name}/{file_name}/{backup_type}/{backup_filename}")
+        
+        except Exception as e:
+            result['error'] = str(e)
+            print(f"Erreur cr√©ation backup: {e}")
+    
+        return result
+    
+    def _apply_rotation(self, backup_folder: str, backup_type: str):
+        """Applique la rotation des fichiers pour un type donn√©"""
+        try:
+            max_files = self.ROTATION_CONFIG.get(backup_type)
+            if max_files is None:
+                return  # Pas de rotation pour ce type
+            
+            # Lister tous les fichiers de sauvegarde dans ce dossier
+            backup_files = []
+            for file in os.listdir(backup_folder):
+                file_path = os.path.join(backup_folder, file)
+                if os.path.isfile(file_path):
+                    backup_files.append({
+                        'path': file_path,
+                        'name': file,
+                        'mtime': os.path.getmtime(file_path)
+                    })
+            
+            # Trier par date de modification (plus ancien en premier)
+            backup_files.sort(key=lambda x: x['mtime'])
+            
+            # Supprimer les fichiers exc√©dentaires
+            while len(backup_files) >= max_files:
+                oldest_file = backup_files.pop(0)
+                try:
+                    os.remove(oldest_file['path'])
+                    print(f"Rotation: suppression de {oldest_file['name']}")
+                    
+                    # Supprimer des m√©tadonn√©es si pr√©sent
+                    self._remove_from_metadata(oldest_file['path'])
+                    
+                except Exception as e:
+                    print(f"Erreur suppression rotation {oldest_file['name']}: {e}")
+            
+            if backup_type == BackupType.REALTIME_EDIT:
+                print(f"Rotation editing: {len(backup_files) + 1}/{max_files} fichiers")
+                
+        except Exception as e:
+            print(f"Erreur rotation {backup_type}: {e}")
+    
+    def _remove_from_metadata(self, backup_path: str):
+        """Supprime une entr√©e des m√©tadonn√©es par chemin"""
+        try:
+            to_remove = []
+            for backup_id, metadata in self.metadata.items():
+                if metadata.get('backup_path') == backup_path:
+                    to_remove.append(backup_id)
+            
+            for backup_id in to_remove:
+                del self.metadata[backup_id]
+                
+            if to_remove:
+                self._save_metadata()
+                
+        except Exception as e:
+            print(f"Erreur suppression m√©tadonn√©es: {e}")
+    
+    def list_all_backups(self, game_filter: str = None, type_filter: str = None) -> List[Dict]:
+        """Liste toutes les sauvegardes avec la structure hi√©rarchique"""
+        backups = []
+        
+        try:
+            if not os.path.exists(self.backup_root):
+                return backups
+            
+            # Scanner la structure hi√©rarchique: Game_name/file_name/backup_type/
+            for game_name in os.listdir(self.backup_root):
+                if game_filter and game_filter != "Tous" and game_name != game_filter:
+                    continue
+                    
+                game_path = os.path.join(self.backup_root, game_name)
+                if not os.path.isdir(game_path) or game_name.startswith('.'):
+                    continue
+                
+                # Parcourir les fichiers
+                for file_name in os.listdir(game_path):
+                    file_path = os.path.join(game_path, file_name)
+                    if not os.path.isdir(file_path):
+                        continue
+                    
+                    # Parcourir les types de backup
+                    for backup_type in os.listdir(file_path):
+                        if type_filter and backup_type != type_filter:
+                            continue
+                            
+                        type_path = os.path.join(file_path, backup_type)
+                        if not os.path.isdir(type_path):
+                            continue
+                        
+                        # Scanner les fichiers de sauvegarde
+                        for backup_file in os.listdir(type_path):
+                            backup_full_path = os.path.join(type_path, backup_file)
+                            if not os.path.isfile(backup_full_path):
+                                continue
+                            
+                            backup_info = self._get_or_create_backup_info_hierarchical(
+                                backup_full_path, game_name, file_name, backup_type
+                            )
+                            if backup_info:
+                                backups.append(backup_info)
+            
+            # Trier par date de cr√©ation (plus r√©cent en premier)
+            backups.sort(key=lambda x: x['created'], reverse=True)
+            
+        except Exception as e:
+            print(f"Erreur listage backups hi√©rarchiques: {e}")
+        
+        return backups
+    
+    def _get_or_create_backup_info_hierarchical(self, backup_path: str, game_name: str, 
+                                              file_name: str, backup_type: str) -> Optional[Dict]:
+        """Cr√©e les infos de backup pour la structure hi√©rarchique"""
+        try:
+            backup_filename = os.path.basename(backup_path)
+            
+            # Chercher dans les m√©tadonn√©es existantes
+            for backup_id, metadata in self.metadata.items():
+                if metadata.get('backup_path') == backup_path:
+                    return metadata
+            
+            # Cr√©er de nouvelles m√©tadonn√©es
+            stats = os.stat(backup_path)
+            created_time = datetime.datetime.fromtimestamp(stats.st_ctime)
+            backup_id = f"{game_name}_{file_name}_{created_time.strftime('%Y%m%d_%H%M%S')}_{backup_type}"
+            
+            # Reconstruire le nom de fichier source
+            source_filename = self._reconstruct_source_filename(backup_filename, file_name)
+            
+            backup_info = {
+                'id': backup_id,
+                'backup_path': backup_path,
+                'game_name': game_name,
+                'file_name': file_name,
+                'type': backup_type,
+                'created': created_time.isoformat(),
+                'size': stats.st_size,
+                'description': f"Sauvegarde {self.BACKUP_DESCRIPTIONS.get(backup_type, backup_type)}",
+                'source_filename': source_filename,
+                'backup_filename': backup_filename,
+                'source_path': None  # √Ä reconstruire √† la demande
+            }
+            
+            # Sauvegarder dans les m√©tadonn√©es
+            self.metadata[backup_id] = backup_info
+            return backup_info
+            
+        except Exception as e:
+            print(f"Erreur cr√©ation info backup hi√©rarchique {backup_path}: {e}")
+            return None
+    
+    def _reconstruct_source_filename(self, backup_filename: str, file_name: str) -> str:
+        """Reconstruit le nom de fichier source √† partir du backup"""
+        try:
+            # Format: file_name_YYYYMMDD_HHMMSS.ext
+            # Extraire l'extension
+            backup_ext = Path(backup_filename).suffix
+            
+            # Le nom source est g√©n√©ralement le nom du fichier + extension
+            if backup_ext:
+                return f"{file_name}{backup_ext}"
+            else:
+                return f"{file_name}.rpy"  # Extension par d√©faut
+                
+        except Exception as e:
+            print(f"Erreur reconstruction nom source: {e}")
+            return f"{file_name}.rpy"
+    
+    def cleanup_empty_folders(self):
+        """Nettoie les dossiers vides dans la structure hi√©rarchique"""
+        try:
+            cleaned_count = 0
+            
+            # Parcourir tous les jeux
+            for game_name in os.listdir(self.backup_root):
+                game_path = os.path.join(self.backup_root, game_name)
+                if not os.path.isdir(game_path):
+                    continue
+                
+                # Parcourir tous les fichiers
+                for file_name in os.listdir(game_path):
+                    file_path = os.path.join(game_path, file_name)
+                    if not os.path.isdir(file_path):
+                        continue
+                    
+                    # Parcourir tous les types
+                    for backup_type in os.listdir(file_path):
+                        type_path = os.path.join(file_path, backup_type)
+                        if os.path.isdir(type_path) and not os.listdir(type_path):
+                            os.rmdir(type_path)
+                            cleaned_count += 1
+                            print(f"Dossier vide supprim√©: {game_name}/{file_name}/{backup_type}")
+                    
+                    # Supprimer le dossier fichier s'il est vide
+                    if os.path.isdir(file_path) and not os.listdir(file_path):
+                        os.rmdir(file_path)
+                        cleaned_count += 1
+                        print(f"Dossier fichier vide supprim√©: {game_name}/{file_name}")
+                
+                # Supprimer le dossier jeu s'il est vide
+                if os.path.isdir(game_path) and not os.listdir(game_path):
+                    os.rmdir(game_path)
+                    cleaned_count += 1
+                    print(f"Dossier jeu vide supprim√©: {game_name}")
+            
+            if cleaned_count > 0:
+                print(f"Nettoyage: {cleaned_count} dossiers vides supprim√©s")
+            
+            return cleaned_count
+            
+        except Exception as e:
+            print(f"Erreur nettoyage dossiers vides: {e}")
+            return 0
diff --git a/src/components/Backup.svelte b/src/components/Backup.svelte
new file mode 100644
index 0000000..4b71bae
--- /dev/null
+++ b/src/components/Backup.svelte
@@ -0,0 +1,319 @@
+<script lang="ts">
+  import { onMount } from 'svelte';
+  import { apiService } from '../lib/api';
+  import { BACKUP_DESCRIPTIONS } from '../lib/constants';
+
+  // √âtats
+  let backups: any[] = [];
+  let filteredBackups: any[] = [];
+  let loading = true;
+  let error: string | null = null;
+  let statusMessage = 'Chargement...';
+
+  // Filtres
+  let selectedGame = 'Tous';
+  let selectedType = 'Tous';
+  let games: string[] = ['Tous'];
+
+  // Statistiques
+  let totalBackups = 0;
+  let totalGames = 0;
+  let totalSize = 0;
+
+  // Tri
+  let sortColumn: string | null = null;
+  let sortDirection: 'asc' | 'desc' = 'asc';
+
+  // Backup s√©lectionn√©
+  let selectedBackup: any = null;
+
+  async function loadBackups() {
+    loading = true;
+    statusMessage = 'üìÑ Chargement des sauvegardes en cours...';
+    error = null;
+
+    try {
+      const result = await apiService.getBackups(
+        selectedGame !== 'Tous' ? selectedGame : undefined,
+        selectedType !== 'Tous' ? selectedType : undefined
+      );
+
+      if (result.success) {
+        backups = result.backups || [];
+        filteredBackups = backups;
+        updateStatistics();
+        updateGameFilter();
+        statusMessage = `‚úÖ ${backups.length} sauvegardes charg√©es - Pr√™t`;
+      } else {
+        error = result.error || 'Erreur de chargement';
+        statusMessage = '‚ùå Erreur lors du chargement';
+      }
+    } catch (err) {
+      error = err instanceof Error ? err.message : 'Erreur inconnue';
+      statusMessage = '‚ùå Erreur lors du chargement';
+    } finally {
+      loading = false;
+    }
+  }
+
+  function updateStatistics() {
+    totalBackups = filteredBackups.length;
+    totalGames = new Set(filteredBackups.map(b => b.game_name)).size;
+    totalSize = filteredBackups.reduce((sum, b) => sum + (b.size || 0), 0);
+  }
+
+  function updateGameFilter() {
+    const uniqueGames = new Set(backups.map(b => b.game_name));
+    games = ['Tous', ...Array.from(uniqueGames).sort()];
+  }
+
+  function formatSize(bytes: number): string {
+    if (bytes < 1024) return `${bytes} B`;
+    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
+    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
+  }
+
+  function formatDate(isoString: string): string {
+    try {
+      const date = new Date(isoString);
+      return date.toLocaleString('fr-FR', {
+        day: '2-digit',
+        month: '2-digit',
+        year: 'numeric',
+        hour: '2-digit',
+        minute: '2-digit'
+      });
+    } catch {
+      return isoString;
+    }
+  }
+
+  function handleFilterChange() {
+    loadBackups();
+  }
+
+  async function restoreBackup(backup: any) {
+    if (!confirm(`Restaurer la sauvegarde ?\n\n‚Ä¢ Fichier : ${backup.source_filename}\n‚Ä¢ Jeu : ${backup.game_name}\n‚Ä¢ Type : ${BACKUP_DESCRIPTIONS[backup.type as keyof typeof BACKUP_DESCRIPTIONS] || backup.type}\n\nLe fichier actuel sera remplac√© !`)) {
+      return;
+    }
+
+    try {
+      statusMessage = 'üîÑ Restauration en cours...';
+      const result = await apiService.restoreBackup(backup.id);
+      
+      if (result.success) {
+        statusMessage = '‚úÖ Restauration termin√©e avec succ√®s';
+        loadBackups(); // Recharger la liste
+      } else {
+        statusMessage = '‚ùå Erreur lors de la restauration';
+        alert(`Erreur : ${result.error}`);
+      }
+    } catch (err) {
+      statusMessage = '‚ùå Erreur lors de la restauration';
+      alert(`Erreur : ${err instanceof Error ? err.message : 'Erreur inconnue'}`);
+    }
+  }
+
+  async function deleteBackup(backup: any) {
+    if (!confirm(`Supprimer d√©finitivement cette sauvegarde ?\n\n‚Ä¢ Fichier : ${backup.source_filename}\n‚Ä¢ Jeu : ${backup.game_name}\n‚Ä¢ Taille : ${formatSize(backup.size)}\n\nCette action est irr√©versible !`)) {
+      return;
+    }
+
+    try {
+      statusMessage = 'üóëÔ∏è Suppression en cours...';
+      const result = await apiService.deleteBackup(backup.id);
+      
+      if (result.success) {
+        statusMessage = '‚úÖ Sauvegarde supprim√©e avec succ√®s';
+        loadBackups(); // Recharger la liste
+      } else {
+        statusMessage = '‚ùå Erreur lors de la suppression';
+        alert(`Erreur : ${result.error}`);
+      }
+    } catch (err) {
+      statusMessage = '‚ùå Erreur lors de la suppression';
+      alert(`Erreur : ${err instanceof Error ? err.message : 'Erreur inconnue'}`);
+    }
+  }
+
+  function sortBy(column: string) {
+    if (sortColumn === column) {
+      sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
+    } else {
+      sortColumn = column;
+      sortDirection = 'asc';
+    }
+
+    filteredBackups = [...filteredBackups].sort((a, b) => {
+      let aVal = a[column];
+      let bVal = b[column];
+
+      if (column === 'created') {
+        aVal = new Date(aVal).getTime();
+        bVal = new Date(bVal).getTime();
+      } else if (column === 'size') {
+        aVal = parseInt(aVal) || 0;
+        bVal = parseInt(bVal) || 0;
+      }
+
+      if (sortDirection === 'asc') {
+        return aVal > bVal ? 1 : -1;
+      } else {
+        return aVal < bVal ? 1 : -1;
+      }
+    });
+  }
+
+  onMount(() => {
+    loadBackups();
+  });
+</script>
+
+<div class="h-full bg-gray-900 text-white flex flex-col">
+  <!-- Header -->
+  <div class="p-6 border-b border-gray-700">
+    <h1 class="text-3xl font-bold text-blue-400 mb-2">üóÇÔ∏è Gestionnaire de Sauvegardes</h1>
+    <p class="text-gray-400 text-sm">G√©rez, restaurez et organisez toutes vos sauvegardes de fichiers RenExtract</p>
+  </div>
+
+  <!-- Content -->
+  <div class="flex-1 overflow-y-auto p-6">
+    <!-- Statistiques -->
+    <div class="bg-gray-800 rounded-lg p-6 mb-6">
+      <h2 class="text-lg font-semibold text-blue-400 mb-4">üìä Statistiques des sauvegardes</h2>
+      <div class="grid grid-cols-3 gap-6">
+        <div>
+          <p class="text-gray-400 text-sm">Sauvegardes totales</p>
+          <p class="text-2xl font-bold">{totalBackups}</p>
+        </div>
+        <div>
+          <p class="text-gray-400 text-sm">Jeux concern√©s</p>
+          <p class="text-2xl font-bold">{totalGames}</p>
+        </div>
+        <div>
+          <p class="text-gray-400 text-sm">Taille totale</p>
+          <p class="text-2xl font-bold text-blue-400">{formatSize(totalSize)}</p>
+        </div>
+      </div>
+    </div>
+
+    <!-- Filtres -->
+    <div class="bg-gray-800 rounded-lg p-6 mb-6">
+      <h2 class="text-lg font-semibold text-blue-400 mb-4">üîç Filtres</h2>
+      <div class="grid grid-cols-2 gap-6">
+        <div>
+          <label for="game-filter" class="block text-sm font-medium mb-2">üéÆ Filtrer par jeu :</label>
+          <select
+            id="game-filter"
+            bind:value={selectedGame}
+            onchange={handleFilterChange}
+            class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:outline-none"
+          >
+            {#each games as game}
+              <option value={game}>{game}</option>
+            {/each}
+          </select>
+        </div>
+        <div>
+          <label for="type-filter" class="block text-sm font-medium mb-2">üè∑Ô∏è Filtrer par type :</label>
+          <select
+            id="type-filter"
+            bind:value={selectedType}
+            onchange={handleFilterChange}
+            class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:outline-none"
+          >
+            <option value="Tous">Tous</option>
+            {#each Object.entries(BACKUP_DESCRIPTIONS) as [key, value]}
+              <option value={key}>{value}</option>
+            {/each}
+          </select>
+        </div>
+      </div>
+    </div>
+
+    <!-- Liste des sauvegardes -->
+    <div class="bg-gray-800 rounded-lg p-6">
+      <h2 class="text-lg font-semibold text-blue-400 mb-4">üìã Liste des sauvegardes</h2>
+      
+      {#if loading}
+        <div class="flex items-center justify-center py-12">
+          <div class="w-10 h-10 border-4 border-gray-600 border-t-blue-500 rounded-full animate-spin"></div>
+          <p class="ml-4 text-gray-400">Chargement...</p>
+        </div>
+      {:else if error}
+        <div class="text-center py-12 text-red-400">
+          <p>‚ùå {error}</p>
+          <button
+            class="mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors"
+            onclick={loadBackups}
+          >
+            R√©essayer
+          </button>
+        </div>
+      {:else if filteredBackups.length === 0}
+        <div class="text-center py-12 text-gray-400">
+          <p>Aucune sauvegarde trouv√©e</p>
+        </div>
+      {:else}
+        <div class="overflow-x-auto">
+          <table class="w-full">
+            <thead class="bg-gray-700">
+              <tr>
+                <th class="px-4 py-3 text-left cursor-pointer hover:bg-gray-600" onclick={() => sortBy('game_name')}>
+                  Jeu {sortColumn === 'game_name' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
+                </th>
+                <th class="px-4 py-3 text-left cursor-pointer hover:bg-gray-600" onclick={() => sortBy('source_filename')}>
+                  Fichier {sortColumn === 'source_filename' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
+                </th>
+                <th class="px-4 py-3 text-left cursor-pointer hover:bg-gray-600" onclick={() => sortBy('type')}>
+                  Type {sortColumn === 'type' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
+                </th>
+                <th class="px-4 py-3 text-left cursor-pointer hover:bg-gray-600" onclick={() => sortBy('created')}>
+                  Date {sortColumn === 'created' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
+                </th>
+                <th class="px-4 py-3 text-left cursor-pointer hover:bg-gray-600" onclick={() => sortBy('size')}>
+                  Taille {sortColumn === 'size' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
+                </th>
+                <th class="px-4 py-3 text-center">Actions</th>
+              </tr>
+            </thead>
+            <tbody>
+              {#each filteredBackups as backup}
+                <tr class="border-t border-gray-700 hover:bg-gray-750 transition-colors">
+                  <td class="px-4 py-3">{backup.game_name}</td>
+                  <td class="px-4 py-3">{backup.source_filename}</td>
+                  <td class="px-4 py-3">{(BACKUP_DESCRIPTIONS as any)[backup.type] || backup.type}</td>
+                  <td class="px-4 py-3">{formatDate(backup.created)}</td>
+                  <td class="px-4 py-3">{formatSize(backup.size)}</td>
+                  <td class="px-4 py-3 text-center">
+                    <div class="flex items-center justify-center gap-2">
+                      <button
+                        class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm transition-colors"
+                        onclick={() => restoreBackup(backup)}
+                        title="Restaurer"
+                      >
+                        üíæ Restaurer
+                      </button>
+                      <button
+                        class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded text-sm transition-colors"
+                        onclick={() => deleteBackup(backup)}
+                        title="Supprimer"
+                      >
+                        üóëÔ∏è
+                      </button>
+                    </div>
+                  </td>
+                </tr>
+              {/each}
+            </tbody>
+          </table>
+        </div>
+      {/if}
+    </div>
+  </div>
+
+  <!-- Footer / Status -->
+  <div class="p-4 border-t border-gray-700 bg-gray-800">
+    <p class="text-sm text-gray-400">üìä √âtat : {statusMessage}</p>
+  </div>
+</div>
diff --git a/src/components/ContentManager.svelte b/src/components/ContentManager.svelte
index b3ef556..3cee9af 100644
--- a/src/components/ContentManager.svelte
+++ b/src/components/ContentManager.svelte
@@ -1,6 +1,7 @@
 <script lang="ts">
   import { appState } from '../stores/app';
   import ActionButtons from './ActionButtons.svelte';
+  import Backup from './Backup.svelte';
   import MainEditor from './MainEditor.svelte';
   import Settings from './Settings.svelte';
   import WorkFolders from './WorkFolders.svelte';
@@ -54,18 +55,7 @@
       </div>
     </div>
   {:else if currentSection === 'backup'}
-    <div class="p-6">
-      <h2 class="text-2xl font-bold mb-4">üíæ Sauvegarde</h2>
-      <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
-        <p class="text-gray-300">Module backup en cours de d√©veloppement...</p>
-        <div class="mt-6">
-          <h3 class="text-lg font-semibold mb-3">Architecture pr√©vue :</h3>
-          <ul class="space-y-2 text-gray-400">
-            <li>üíæ Gestionnaire sauvegardes</li>
-          </ul>
-        </div>
-      </div>
-    </div>
+    <Backup />
   {:else}
     <!-- Fallback -->
     <div class="p-6">
diff --git a/src/components/Settings.svelte b/src/components/Settings.svelte
index 7f417c9..75ca2e9 100644
--- a/src/components/Settings.svelte
+++ b/src/components/Settings.svelte
@@ -1,95 +1,14 @@
 <script lang="ts">
   import { onMount } from 'svelte';
   import { apiService } from '../lib/api';
+  import { DEFAULT_SETTINGS } from '../lib/constants';
   import { i18n } from '../lib/i18n';
   import { appActions } from '../stores/app';
   import CustomModal from './CustomModal.svelte';
   import ThemeCustomizer from './ThemeCustomizer.svelte';
 
   // Configuration model - simplified debug mode
-  let config = {
-    language: 'fr',
-    theme: 'dark',
-    debugActive: false, // Single debug mode (false=Level 3, true=Level 4)
-    autoOpenings: {
-      files: true,
-      folders: true,
-      reports: false,
-      outputField: false
-    },
-    externalTools: {
-      textEditor: 'VS Code',
-      translator: ''
-    },
-    paths: {
-      renpySdk: '',
-      vscode: '',
-      sublime: '',
-      notepad: '',
-      atom: ''
-    },
-    folders: {
-      temporary: '01_Temporary/',
-      reports: '02_Reports/',
-      backups: '03_Backups/',
-      configs: '04_Configs/'
-    },
-    extraction: {
-      placeholderFormat: 'PLACEHOLDER_{n}',
-      encoding: 'UTF-8'
-    },
-    colors: {
-      // Couleurs de base
-      background: {
-        primary: '#1a1a1a',
-        secondary: '#2a2a2a',
-        tertiary: '#3a3a3a',
-        header: '#262626',
-        sidebar: '#1e1e1e',
-        modal: '#2a2a2a',
-        input: '#3a3a3a'
-      },
-      text: {
-        primary: '#ffffff',
-        secondary: '#cccccc',
-        tertiary: '#999999',
-        placeholder: '#666666',
-        accent: '#60a5fa'
-      },
-      border: {
-        primary: '#4a4a4a',
-        secondary: '#5a5a5a',
-        focus: '#60a5fa',
-        hover: '#6a6a6a'
-      },
-      // Couleurs des boutons
-      buttons: {
-        extract: '#3B82F6',
-        reconstruct: '#10B981',
-        verify: '#F59E0B',
-        dangerous: '#ef4444',
-        warning: '#f59e0b',
-        success: '#10b981',
-        neutral: '#6b7280'
-      },
-      // Couleurs d'accent
-      accent: {
-        primary: '#6366F1',
-        secondary: '#8b5cf6',
-        highlight: '#60a5fa',
-        success: '#10b981',
-        warning: '#f59e0b',
-        danger: '#ef4444'
-      },
-      // √âtats sp√©ciaux
-      states: {
-        hover: '#404040',
-        active: '#505050',
-        disabled: '#666666',
-        selected: '#4f46e5'
-      }
-    }
-  };
+  let config = { ...DEFAULT_SETTINGS };
 
   // Tab management
   let activeTab = 'interface_applications';
diff --git a/src/components/WorkFolders.svelte b/src/components/WorkFolders.svelte
index b00d6ab..718b5cf 100644
--- a/src/components/WorkFolders.svelte
+++ b/src/components/WorkFolders.svelte
@@ -1,13 +1,6 @@
 <script lang="ts">
   import Icon from "@iconify/svelte";
-
-
-  const workFolders = [
-    { id: '01', name: '01_Temporary', icon: 'hugeicons:folder-02', color: 'bg-yellow-700' },
-    { id: '02', name: '02_Reports', icon: 'hugeicons:analysis-text-link', color: 'bg-blue-600' },
-    { id: '03', name: '03_Backups', icon: 'hugeicons:floppy-disk', color: 'bg-purple-600' },
-    { id: '04', name: '04_Configs', icon: 'hugeicons:settings-02', color: 'bg-gray-600' }
-  ];
+  import { WORK_FOLDERS } from '../lib/constants';
 
   let outputFolder = 'Non d√©fini';
 
@@ -24,10 +17,11 @@
   <h3 class="text-blue-400 text-lg font-semibold mb-4">Dossiers de travail</h3>
   
   <div class="grid grid-cols-4 gap-4 mb-6">
-    {#each workFolders as {name, icon, color, id}}
+    {#each WORK_FOLDERS as {name, icon, color, id, description}}
       <button
         onclick={() => selectFolder(id)}
         class="flex items-center gap-3 p-4 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors text-left"
+        title={description}
       >
         <div class="w-10 h-10 {color} rounded-lg flex items-center justify-center text-white">
           <Icon {icon} class="w-6 h-6" />
diff --git a/src/lib/api.ts b/src/lib/api.ts
index 95c7f13..92f8237 100644
--- a/src/lib/api.ts
+++ b/src/lib/api.ts
@@ -21,6 +21,18 @@ export interface SettingsUpdateResponse {
   message: string;
 }
 
+export interface BackupListResponse {
+  success: boolean;
+  backups?: any[];
+  error?: string;
+}
+
+export interface BackupActionResponse {
+  success: boolean;
+  message?: string;
+  error?: string;
+}
+
 // Service API
 export const apiService = {
   async healthCheck(): Promise<HealthResponse> {
@@ -68,5 +80,48 @@ export const apiService = {
         error: error instanceof Error ? error.message : 'Unknown error'
       };
     }
+  },
+
+  async getBackups(gameFilter?: string, typeFilter?: string): Promise<BackupListResponse> {
+    try {
+      const params = new URLSearchParams();
+      if (gameFilter) params.append('game', gameFilter);
+      if (typeFilter) params.append('type', typeFilter);
+      
+      const response = await api.get(`/backups?${params.toString()}`);
+      return response.data;
+    } catch (error) {
+      console.error('Get Backups Error:', error);
+      return {
+        success: false,
+        error: error instanceof Error ? error.message : 'Unknown error'
+      };
+    }
+  },
+
+  async restoreBackup(backupId: string): Promise<BackupActionResponse> {
+    try {
+      const response = await api.post(`/backups/${backupId}/restore`);
+      return response.data;
+    } catch (error) {
+      console.error('Restore Backup Error:', error);
+      return {
+        success: false,
+        error: error instanceof Error ? error.message : 'Unknown error'
+      };
+    }
+  },
+
+  async deleteBackup(backupId: string): Promise<BackupActionResponse> {
+    try {
+      const response = await api.delete(`/backups/${backupId}`);
+      return response.data;
+    } catch (error) {
+      console.error('Delete Backup Error:', error);
+      return {
+        success: false,
+        error: error instanceof Error ? error.message : 'Unknown error'
+      };
+    }
   }
 };
diff --git a/src/lib/constants.ts b/src/lib/constants.ts
new file mode 100644
index 0000000..a041712
--- /dev/null
+++ b/src/lib/constants.ts
@@ -0,0 +1,144 @@
+/**
+ * Constants and Configuration for RenExtract v2
+ * Centralized folder definitions and application constants
+ */
+
+// ========================================
+// FOLDER DEFINITIONS
+// ========================================
+
+export const FOLDERS = {
+  TEMPORARY: '01_Temporary',
+  REPORTS: '02_Reports', 
+  BACKUPS: '03_Backups',
+  CONFIGS: '04_Configs'
+} as const;
+
+export const WORK_FOLDERS = [
+  { 
+    id: '01', 
+    name: FOLDERS.TEMPORARY, 
+    icon: 'hugeicons:folder-02', 
+    color: 'bg-yellow-700',
+    description: 'Fichiers temporaires et de travail'
+  },
+  { 
+    id: '02', 
+    name: FOLDERS.REPORTS, 
+    icon: 'hugeicons:analysis-text-link', 
+    color: 'bg-blue-600',
+    description: 'Rapports d\'extraction et d\'analyse'
+  },
+  { 
+    id: '03', 
+    name: FOLDERS.BACKUPS, 
+    icon: 'hugeicons:floppy-disk', 
+    color: 'bg-purple-600',
+    description: 'Sauvegardes automatiques et manuelles'
+  },
+  { 
+    id: '04', 
+    name: FOLDERS.CONFIGS, 
+    icon: 'hugeicons:settings-02', 
+    color: 'bg-gray-600',
+    description: 'Fichiers de configuration et param√®tres'
+  }
+] as const;
+
+// ========================================
+// BACKUP TYPES
+// ========================================
+
+export const BACKUP_TYPES = {
+  SECURITY: 'security',
+  CLEANUP: 'cleanup',
+  RPA_BUILD: 'rpa_build',
+  REALTIME_EDIT: 'realtime_edit'
+} as const;
+
+export const BACKUP_DESCRIPTIONS = {
+  [BACKUP_TYPES.SECURITY]: 'üõ°Ô∏è S√©curit√©',
+  [BACKUP_TYPES.CLEANUP]: 'üßπ Nettoyage',
+  [BACKUP_TYPES.RPA_BUILD]: 'üì¶ Avant RPA',
+  [BACKUP_TYPES.REALTIME_EDIT]: '‚ö° √âdition temps r√©el'
+} as const;
+
+// ========================================
+// APPLICATION CONSTANTS
+// ========================================
+
+export const APP_CONFIG = {
+  NAME: 'RenExtract',
+  VERSION: '2.0.0',
+  AUTHOR: 'Rory Mercury91',
+  DESCRIPTION: 'Outil d\'extraction et de pr√©paration √† la traduction pour les jeux Ren\'Py'
+} as const;
+
+// ========================================
+// DEFAULT SETTINGS
+// ========================================
+
+export const DEFAULT_SETTINGS = {
+  language: 'fr',
+  theme: 'dark',
+  debugActive: false,
+  autoOpenings: {
+    files: true,
+    folders: true,
+    reports: false,
+    outputField: false
+  },
+  externalTools: {
+    textEditor: 'VS Code',
+    translator: ''
+  },
+  paths: {
+    renpySdk: '',
+    vscode: '',
+    sublime: '',
+    notepad: '',
+    atom: ''
+  },
+  folders: {
+    temporary: `${FOLDERS.TEMPORARY}/`,
+    reports: `${FOLDERS.REPORTS}/`,
+    backups: `${FOLDERS.BACKUPS}/`,
+    configs: `${FOLDERS.CONFIGS}/`
+  },
+  extraction: {
+    placeholderFormat: 'PLACEHOLDER_{n}',
+    encoding: 'UTF-8'
+  }
+} as const;
+
+// ========================================
+// UTILITY FUNCTIONS
+// ========================================
+
+export function getFolderPath(folderName: keyof typeof FOLDERS): string {
+  return FOLDERS[folderName];
+}
+
+export function getWorkFolderById(id: string) {
+  return WORK_FOLDERS.find(folder => folder.id === id);
+}
+
+export function getAllFolderNames(): string[] {
+  return Object.values(FOLDERS);
+}
+
+export function validateFolderName(name: string): boolean {
+  if (!name || typeof name !== 'string') return false;
+  if (name.length > 255 || name.length < 1) return false;
+  if (/[<>:"|?*\\/]/.test(name)) return false;
+  if (name.startsWith(' ') || name.endsWith(' ') || name.startsWith('.') || name.endsWith('.')) return false;
+  return true;
+}
+
+// ========================================
+// TYPE EXPORTS
+// ========================================
+
+export type FolderName = keyof typeof FOLDERS;
+export type BackupType = keyof typeof BACKUP_TYPES;
+export type WorkFolder = typeof WORK_FOLDERS[number];
-- 
2.51.0

